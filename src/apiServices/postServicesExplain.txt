import { connectDB } from "@/lib/mongodb";
import { Post, IPost } from "@/models/post";
connectDB: a helper function that connects to your MongoDB cluster using Mongoose.

Post: your Mongoose model (like User, Product, etc.).

IPost: the TypeScript interface that defines what a Post document looks like (title, content, slug, tags, etc.).



2ï¸âƒ£ Defining options for listing posts
export type PostListOptions = {
  page?: number;
  limit?: number;
  search?: string;
  tags?: string[];
  publishedOnly?: boolean;
};


This defines what kind of options you can pass to the function that lists posts (getPosts).

Letâ€™s break it down:

Field	Type	Meaning
page?	number	which page number you want (for pagination)
limit?	number	how many posts per page
search?	string	search keyword (for filtering posts)
tags?	string[]	list of tags to filter posts by
publishedOnly?	boolean	if true, only return published posts


ğŸŸ¢ Why use type and not interface?

You could use either one here â€” both work, but thereâ€™s a nuance:

âœ… Use type when you want to describe an object shape (like { page?: number; })
and maybe combine it with union types, intersections, or literal types later.

âœ… Use interface when defining data models or objects that may be extended or implemented by a class.

In this context, PostListOptions is not a data model â€” itâ€™s just a function argument type.
So using type is lightweight and perfect for this use.

ğŸ‘‰ You could also have written:

export interface PostListOptions { ... }


and it would still work fine â€” itâ€™s mostly stylistic here.



export async function createPost(payload: Partial<IPost>) {
  await connectDB();
  const p = new Post(payload);
  return p.save();
}
Breakdown:

Partial<IPost> means the argument can contain some or all properties of IPost.
(You might not provide every field when creating.)

connectDB() ensures MongoDB is connected before doing anything.

new Post(payload) creates a new Mongoose post document.

.save() writes it to the database.



5ï¸âƒ£ Get multiple posts (list)
export async function getPosts(options: PostListOptions = {}) {
  await connectDB();
  const page = Math.max(1, options.page ?? 1);
  const limit = Math.min(50, options.limit ?? 10);
  const skip = (page - 1) * limit;


options: PostListOptions = {} â†’ default to empty if none provided.

page ?? 1 â†’ use 1 if page is undefined.

Math.max(1, ...) â†’ make sure page number is not below 1.

limit ?? 10 â†’ default 10 posts per page.

Math.min(50, limit) â†’ cap at 50 max per page.

skip â†’ used for pagination (page 2 skips first 10 items, etc.).




6ï¸âƒ£ Building the MongoDB query filter
const filter: any = {};
if (options.publishedOnly !== false) filter.published = true;
if (options.search) {
  filter.$or = [
    { title: new RegExp(options.search, "i") },
    { excerpt: new RegExp(options.search, "i") },
    { content: new RegExp(options.search, "i") },
  ];
}
if (options.tags && options.tags.length) filter.tags = { $in: options.tags };


Letâ€™s unpack this carefully:

Code	Meaning
filter: any = {}	start with an empty query object
filter.published = true	only show published posts by default
new RegExp(options.search, "i")	case-insensitive search (matches anywhere in title, excerpt, or content)
$or	tells MongoDB â€œmatch any of these fieldsâ€
$in	matches posts that have any of the given tags

âœ… Result: this filter dynamically changes based on what the user is searching for or filtering by.


const [items, total] = await Promise.all([
  Post.find(filter).sort({ createdAt: -1 }).skip(skip).limit(limit).lean().exec(),
  Post.countDocuments(filter),
]);
Promise.all() runs both at once for speed.

items: fetches the actual posts.

total: counts how many posts match the filter.

.sort({ createdAt: -1 }) sorts newest first.

.skip() and .limit() implement pagination.



8ï¸âƒ£ Return structured data
return {
  items,
  total,
  page,
  limit,
  pages: Math.ceil(total / limit) || 1,
};


This provides everything your frontend needs to:

Display posts

pages: Math.ceil(total / limit) || 1
means:

â€œCalculate how many pages are needed by dividing total posts by posts per page,
round up to the nearest integer, and default to 1 if the result is invalid.â€

ğŸ’¬ Plain English version:
â€œIf you have 27 posts and youâ€™re showing 8 per page, youâ€™ll need 4 pages.
But if there are no posts, still show at least 1 empty page.â€



âœ… Example in context:
total	limit	total/limit	Math.ceil	          pages
27	     8	   3.375	     4	              âœ… 4 pages
16	     8	   2	         2	              âœ… 2 pages
0	       8	   0	         0 â†’ fallback	    âœ… 1 page



9ï¸âƒ£ Update post by slug
export async function updatePostBySlug(slug: string, updates: Partial<IPost>) {
  await connectDB();
  return Post.findOneAndUpdate({ slug }, updates, { new: true }).exec();
}


Finds a post by its slug and updates the provided fields.
{ new: true } ensures it returns the updated version, not the old one.



ğŸ”Ÿ Delete post by slug
export async function deletePostBySlug(slug: string) {
  await connectDB();
  return Post.findOneAndDelete({ slug }).exec();
}


Deletes the post matching the slug.



ğŸ”Ÿ Delete post by slug
export async function deletePostBySlug(slug: string) {
  await connectDB();
  return Post.findOneAndDelete({ slug }).exec();
}


Deletes the post matching the slug.

ğŸ§  Summary Table
Function	Purpose
createPost()	Insert new post
getPostBySlug()	Get a single post by unique slug
getPosts()	List posts with search, tag, and pagination support
updatePostBySlug()	Edit post fields
deletePostBySlug()	Remove a post from DB

âœ… In short:
This file is the â€œPost service layerâ€ â€”
a clean, reusable module that isolates all MongoDB queries in one place.

Thatâ€™s why your React pages donâ€™t need to know about database details â€” they just call functions like:

const posts = await getPosts();
const post = await getPostBySlug(slug);






About Type and interface
You can also extend interfaces:

interface Person {
  name: string;
}
interface Employee extends Person {
  position: string;
}


Interfaces are best when describing data models, class contracts, or API response shapes â€” things that describe what an object looks like.

ğŸ§  2. What is a Type Alias?

A type alias is more flexible â€” it can describe any type, not just object shapes.

You can use it for:

Unions (|)

Intersections (&)

Primitive aliases

Function types

Complex combinations

Example:
type ID = string | number;

type User = {
  name: string;
  age: number;
};

type ApiResponse = User | { error: string };


So while interface is limited to describing objects and classes,
type can describe almost anything.






ğŸ§© 1. Meaning of payload

The word payload simply means the actual data being sent or received.
Itâ€™s a common term in APIs or backend logic â€” think of it as â€œthe body of the request.â€

For example, when you create a blog post, you might send this from your frontend:

{
  "title": "My First Post",
  "content": "Hello world!",
  "tags": ["intro"]
}


That JSON object is your payload â€” it contains the actual information the backend needs to create something in the database.

So in this function:

export async function createPost(payload: Partial<IPost>) {
  await connectDB();
  const p = new Post(payload);
  return p.save();
}


payload is the data you pass in to create a new Post document.




  return Post.findOne({ slug }).lean<IPost>().exec();
ğŸ§  Putting it all together:

Letâ€™s rewrite that line in plain English:

â€œFind one post document in MongoDB where the slug matches the given slug,
return it as a plain JavaScript object (typed as IPost),
and execute the query immediately.â€

âœ… Final Flow (in your getPostBySlug):
export async function getPostBySlug(slug: string) {
  await connectDB();                     // make sure MongoDB is connected
  return Post.findOne({ slug })          // find a post where slug matches
    .lean<IPost>()                       // return a lightweight plain object
    .exec();                             // execute the query (returns a Promise)
}


Result when called:

const post = await getPostBySlug("my-first-post");

console.log(post.title); // âœ… works, typed as string
console.log(post.content); // âœ… works



ğŸ’¡ Summary Table:
Part	Meaning	Purpose
Post	Mongoose model	Represents your MongoDB collection
.findOne({ slug })	Query	Finds one document with a matching slug
.lean()	Optimization	Converts Mongoose document â†’ plain JS object
<IPost>	TypeScript generic	Adds type safety to the result
.exec()	Execution method	Runs the query and returns a Promise




